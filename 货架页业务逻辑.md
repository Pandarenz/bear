# 货架页业务逻辑
## 货架页文件结构
biz_show_category
├─ Classes
│    ├─ Constants
│    │    ├─ CategoryApi.swift   接口path管理
│    │    ├─ CategoryConstant.swift
│    │    └─ TagDefaults.swift   本地存储的标新管理类
│    ├─ Search  顶部导航搜索页面
│    │    ├─ SearchController.swift
│    │    ├─ SearchDataHelper.swift
│    │    ├─ SearchInfo.swift
│    │    ├─ SearchPresenter.swift
│    │    └─ View
│    ├─ SearchRes  搜索结果页面
│    │    ├─ Cell
│    │    ├─ CellGroup
│    │    ├─ SearchResView
│    │    ├─ SearchResultController.swift
│    │    ├─ SearchResultPresenter.swift
│    │    └─ SearchWrapper.swift
│    ├─ Shelf 
│    │    ├─ Model
│    │    ├─ ShelfDetailGroup.swift
│    │    ├─ ShelfDetailPresenter.swift
│    │    ├─ ShelfDetailViewController.swift   货架页详情 
│    │    ├─ ShelfDetailWrapper.swift
│    │    ├─ ShelfEntranceController.swift    货架页入口
│    │    ├─ ShelfFramesPresenter.swift
│    │    ├─ ShelfPagePreLoader.swift   货架详情预加载处理
│    │    ├─ ShelfSubTagWrapper.swift
│    │    └─ View
│    ├─ TagFilter
│    │    ├─ FirstLvTag   一级货架
│    │    └─ SecondLvTag  二级货架
│    ├─ ZZCategoryTargetImpl.swift
├─ biz_show_category.bundle

## 货架页面入口
![](%E8%B4%A7%E6%9E%B6%E9%A1%B5%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/36C2FE4B-E139-403C-B62B-27A03B0576F1.png)

1. 左边一级货架： 实现为封装的 TagNamesCollectionView
2. 右边二级货架： 实现为封装的 TagItemCollectionView 
3. 左边点击刷新右边 TagItemCollectionView 的数据
4. 右边滑动联动更新左边数据
5. 点击过后或者刷新数据处理标新

注意： 由于右边需要切换的动画，所以右边模块始终存在两
个TagItemCollectionView 来回切换。
具体参考下面：
![](%E8%B4%A7%E6%9E%B6%E9%A1%B5%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/DAD2B8B1-FA19-4030-BA19-4D69418D71CA.png)

switchToNext    滑向下一篇
 switchToPrevious  滑向上一篇
loadNextCollectionView  准备好即将出现的collection

> 在改动此块需注意左右联动，并且保持数据展示正确  

## 货架详情
这个页面主要涉及到两个scrollView的嵌套，实现下拉、上滑改变头部标题的动画

1. 商品展示 UICollectionView ShelfDetailCollectionView 
2. 容器scrollView: ShelfDetailScrollView
3. 注意在此页面需要处理两个 scrollView 嵌套的手势冲突，主要代码如下：

![](%E8%B4%A7%E6%9E%B6%E9%A1%B5%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/AA0C1629-0485-4B47-93DB-DBE2FF6CE62E.png)

 通过 scrollView delegate方法，判断滚动距离来决定让哪一个scrollView滚动
```swift
func scrollViewDidScroll(_ scrollView: UIScrollView) {
    if self.isExpand {
        self.expandOrCollapseHeadImage()
        return
    }
    let parentMaxCanOffset = imgCollapseH-NavigationH
    if childScrollView.goingUp { // 上滚
        if scrollView == childScrollView {
            if parentScrollView.contentOffset.y < parentMaxCanOffset && !childScrollingDown {
                let parentYoffset = max(min(parentScrollView.contentOffset.y + childScrollView.contentOffset.y, parentMaxCanOffset), 0)
                parentScrollView.contentOffset.y = parentYoffset
                childScrollView.contentOffset.y = 0
            }
        }
    } else { // 下滚
//            if scrollView == childScrollView {
//                if childScrollView.contentOffset.y < 0 && parentScrollView.contentOffset.y > 0 {
//                    parentScrollView.contentOffset.y = max(parentScrollView.contentOffset.y - abs(childScrollView.contentOffset.y), 0)
//                }
//            }
        if scrollView == parentScrollView {
            if childScrollView.contentOffset.y > 0 && parentScrollView.contentOffset.y < parentMaxCanOffset {
                childScrollingDown = true
                let childYoffset = max(childScrollView.contentOffset.y, 0)
                childScrollView.contentOffset.y = childYoffset
                parentScrollView.contentOffset.y = parentMaxCanOffset
                childScrollingDown = false
            }
        }
    }
    
    if scrollView == childScrollView {
        isScrolling = true
    }
}
```

4. 还有就是在商品展示的大小图切换时，需要注意从新对collectionView布局，重新计算cell高度（取一行中最高的）具体代码参考：

```swift
// 小图情况下cell高度计算（取一行中最高的）
private func caculateHeight(_ arr: [ShelfDetailWrapper], isLoadMore: Bool = false) {
    if arr.isEmpty {
        return
    }
    if self.isBigBrowe { // 大图
        for (index, value) in arr.enumerated() {
            var bottomMargin = (value.shelfItem?.onlyCover() ?? true) ? 5 : 30
            if isLoadMore && value.cellHeight > 0 {
                bottomMargin = 0
            }
            let indexPath = IndexPath(item: index, section: 0)
            let height = ShelfDetailItemCell.getCellSize(indexPath, model: value).height
            value.cellHeight = height + CGFloat(bottomMargin)
            value.cellWidth = AppWidth
        }
    } else {
        // 先计算行数
        var lineN: Int = 0
        let count = arr.count
        // 判断是否是奇数
        let isOdd = count % 2 != 0
        // 奇数需要+1
        lineN = (isOdd ? count + 1 : count) / 2
        for i in 0..<lineN {
            let leftIndex = i*2
            let rightIndex = leftIndex + 1
            if leftIndex < count {
                var leftBottomMargin = (arr[leftIndex].shelfItem?.onlyCover() ?? true) ? 5 : 30
                let leftIndexPath = IndexPath(item: leftIndex, section: 0)
                if isLoadMore && arr[leftIndex].cellHeight > 0 { // 加载更多
                    leftBottomMargin = 0
                }
                let leftHeight = ShelfDetailItemCell.getCellSize(leftIndexPath, model: arr[leftIndex]).height + CGFloat(leftBottomMargin)
                if rightIndex < count {
                    var rightBottomMargin = (arr[rightIndex].shelfItem?.onlyCover() ?? true) ? 5 : 30
                    let rightIndexPath = IndexPath(item: rightIndex, section: 0)
                    if isLoadMore && arr[rightIndex].cellHeight > 0 { // 加载更多
                        rightBottomMargin = 0
                    }
                    let rightHeight = ShelfDetailItemCell.getCellSize(rightIndexPath, model: arr[rightIndex]).height + CGFloat(rightBottomMargin)
                    let lineHeight = max(leftHeight, rightHeight)
                    
                    arr[leftIndex].cellHeight = lineHeight
                    arr[leftIndex].cellWidth = (AppWidth - 5)/2
                    
                    arr[rightIndex].cellHeight = lineHeight
                    arr[rightIndex].cellWidth = (AppWidth - 5)/2
                } else { // 有可能大于的
                    arr[leftIndex].cellHeight = leftHeight
                    arr[leftIndex].cellWidth = (AppWidth - 5)/2
                }
            }
        }
    }
}
```

## 货架分页预加载
* 在UICollectionViewDelegate函数willDisplay中，计算要显示的Cell距离屏幕底部的距离，提前3屏加载下一页数据
* 只在WIFI下生效
* 页面级别生效，每个页面需要单独打开

```swift
/// 检查当前cell距离底部间距是否符合预加载要求
private func canPreLoadNexPageDataBySpace(_ curIndex: Int) ->Bool{
    guard let cellContainer = self.cellContainer else {
        return false
    }
    guard let mCollectionView = self.mCollectionView else {
        return false
    }
    
    let count = cellContainer.list.count
    if curIndex < count - 1{
        let curWrapper = cellContainer.list[curIndex]
        if let centerY = curWrapper.option?.centerY{
            
            let contentHeight = mCollectionView.contentSize.height
            let bottomSpace = contentHeight - (centerY + curWrapper.cellHeight / 2)
            if bottomSpace > 0{
                // 距离底部3屏
                let thresholdSpace = AppHeight
                zzlog(“bottomSpace:\(bottomSpace),thresholdSpace:\(thresholdSpace),contentHeight:\(contentHeight)”)
                if bottomSpace <= thresholdSpace{
                    return true
                }
            }
        }
    }
    return false
}
```

> 具体参考 ShelfPagePreLoader 类， globlePagePreLoad变量为预加载全局开关，可控制是否开启预加载  

#造作文档/货架
